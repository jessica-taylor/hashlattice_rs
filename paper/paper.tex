
\documentclass{article}

\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\newtheorem{theorem}{Theorem}

\title{Semilattice Graphs for Distributed Databases}
\author{Jessica Taylor}
\date{\today}

\begin{document}
    \maketitle
    
    \section{Introduction}
        A \emph{semilattice} is a set $L$ with a binary operation $\vee$ (``join'') that is commutative ($x \vee y = y \vee x$), associative ($(x \vee y) \vee z = x \vee (y \vee z)$), and idempotent ($x \vee x = x$).

        In databases, lattices are useful for defining a notion of a most updated value. For example, with $L$ as a set of sets of messages and $\vee = \cup$, the lattice represents sets of messages that are updated to include more messages as they come in.


    \section{Semilattice Graphs}

        A common problem in networked computing is dependency managament. A software package may depend on a set of other packages, each of which depends on another set of packages. We consider extending semilattices to semilattice graphs to handle dependency management.
        
        A \emph{semilattice graph} consists of:

        \begin{itemize}
            \item A set of keys $K$.
            \item A nonempty set of values $V$.
            \item A dependency function $d : K \times V \rightarrow 2^K$ that maps each key to a finite set of keys, its dependencies.
            \item A join function $j : (\Sigma (k: K, x : V, y : V), d(k, x) \cup d(k, y) \rightarrow V) \rightarrow V$ that joins two values given their dependencies. (The sigma set $\Sigma (a: A), B(a)$ denotes a set of pairs $(a, b)$ where $a \in A$ and $b \in B(a)$.)
        \end{itemize}

        And satisfies the following properties:

        \begin{itemize}
            \item $d$ must be well-founded; that is, there are no infinite dependency chains $k_1, k_2, \ldots \in K$ and $v_1, v_2, \ldots \in V$ such that $k_{i+1} \in d(k_i, v_i)$ for $i = 1, 2, \ldots$
            \item $j$ must be a valid join function; for any $k : K$, $g: K \rightarrow V$, defining $x \vee_{k,g} y := j(k, x, y, g|_{d(k, x) \cup d(k, y)})$, then $(V, \vee_{k,g})$ must be a semilattice.
            \item $j$ must not grow dependencies; that is, for any $k : K$, $g: K \rightarrow V$, $x, y \in V$, we must have $d(k, x \vee_{k, g} y) \subseteq d(k, x) \cup d(k, y)$.
        \end{itemize}

        It is now possible to define a semilattice over a semilattice graph. This lattice's items are functions $K \rightarrow V$ (called \emph{mappings}) and the join operation is defined as follows:

        $$ (g_1 \vee g_2)(k) := g_1(k) \vee_{k, (g_1 \vee g_2)} g_2(k) $$

        where the recursion is well-founded due to $d$ being well-founded.

        We must now show that $\vee$ is commutative, associative, and idempotent, inductively. For any natural $n$ we say $\vee$ (applied to semilattice graphs) forms a semilattice up to $n$ if, for any $k : K$ whose longest dependency chain is no longer than $n$, we have:

        \begin{itemize}
          \item $(g_1 \vee g_2)(k) = (g_2 \vee g_1)(k)$
          \item $((g_1 \vee g_2) \vee g_3)(k) = (g_1 \vee (g_2 \vee g_3))(k)$
          \item $(g \vee g)(k) = g(k)$
        \end{itemize}

        We note that if $\vee$ forms a semilattice up to all $n$, then it forms a semilattice. We now note that if $\vee$ forms a semilattice up to $n$, then it forms a semilattice up to $n+1$, inductively:

        % WANT: (g_1(k) \vee_{k, (g_1 \vee g_2)} g_2(k)) \vee_{k, (g_1 \vee g_2 \vee g_3)} g_3(k)
        %     = g_1(k) \vee_{k, g_1 \vee g_2 \vee g_3} (g_2(k) \vee_{k, g_2 \vee g_3} g_3(k))
        % HAVE: (g_1(k) \vee_{k, (g_1 \vee g_2 \vee g_3)}) \vee_{k, (g_1 \vee g_2 \vee g_3)} g_3(k)
        %     = g_1(k) \vee_{k, g_1 \vee g_2 \vee g_3} (g_2(k) \vee_{k, (g_1 \vee g_2 \vee g_3)} g_3(k))

        \begin{itemize}
          \item $(g_1 \vee g_2)(k) = g_2(k) \vee_{k, (g_1 \vee g_2)} g_1(k) = g_2(k) \vee_{k, (g_2 \vee g_1)} g_1(k) = (g_2 \vee g_1)(k)$
          \item
            \begin{align*}
              ((g_1 \vee g_2) \vee g_3))(k) &= (g_1 \vee g_2)(k) \vee_{k, ((g_1 \vee g_2) \vee g_3)} g_3(k) \\
              &= (g_1(k) \vee_{k, (g_1 \vee g_2)} g_2(k)) \vee_{k, (g_1 \vee (g_2 \vee g_3))} g_3(k) \\
              &= g_1(k) \vee_{k, (g_1 \vee g_2)} g_2(k) \vee_{k, (g_1 \vee g_2)} g_3(k) \\
              &= g_1(k) \vee_{k, (g_1 \vee g_2)} (g_2(k) \vee_{k, (g_1 \vee g_2)} g_3(k)) \\
              &= g_1(k) \vee_{k, (g_1 \vee g_2)} (g_2 \vee g_3)(k) \\
              &= (g_1 \vee (g_2 \vee g_3))(k)
            \end{align*}
          \item $(g_1 \vee g_1)(k) = g_1(k) \vee_{k, (g_1 \vee g_1)} g_1(k) = g_1(k)$
        \end{itemize}

    \section{Autofills}

        Mappings may be infinite in general, and even finite ones contain a large number of keys. It is therefore computationally infeasible to store a mapping as a set of $K \times V$ pairs. Accordingly, we define \emph{autofills} to fill in lattice values automatically from a set of other values.


        % Define $d^*(k, g) := \{k\} \cup \bigcup_{k' \in d(k, g(k))} d^*(k', g)$, the transitive closure of $d$, where $g$ is a mapping. The recursion is well-founded (and $d^*(k, g)$ is finite) because $d$ is well-founded.

        % Note that $d^*(k, g_1 \vee g_2) \subseteq d^*(k, g_1) \cup d^*(k, g_2)$.

        An \emph{autofill} for a semilattice graph consists of a dependency function $\hat{d}: K \rightarrow 2^V$ and an autofill function $a : \forall (k:K), \hat{d}(k) \rightarrow V$ that satisfy:

        \begin{itemize}
          \item
            For each $k \in K, v \in V$, $\hat{d}(k) \subseteq d(k, v)$.
          \item
            $a(k, g_1) \vee_{k, g_1 \vee g_2} a(k, g_2) = a(k, g_1 \vee g_2)$; that is, the join of two autofill values on two mappings must be an autofill value on the joined mapping.
        \end{itemize}

        where we write $a(k, g) := a(k, g|_{\hat{d}(k)})$ for brevity.


        A mapping $g : K \rightarrow V$ is an \emph{autofill mapping} if:
        
        \begin{itemize}
          \item $g(k) = a(k, g)$ for all but a finite number of $k$ values.
          \item $g(k) \vee_{k, g} a(k, g) = g(k)$ for all $k \in K$.
        \end{itemize}


        An autofill mapping can be represented as a finite set of $K \times V$ pairs; the remaining values are filled in automatically.

        \begin{theorem}
          Let $g_1, g_2 : K \rightarrow V$ be autofill mappings. Then $g_1 \vee g_2$ is an autofill mapping.
        \end{theorem}

        \begin{proof}

          Whenever $g_1(k) = a(k, g_1)$ and $g_2(k) = a(k, g_2)$ (which is true for all but a finite number of $k$ values):
           $$(g_1 \vee g_2)(k) = g_1(k) \vee_{k, (g_1 \vee g_2)} g_2(k) = a(k, g_1) \vee_{k, g_1 \vee g_2} a(k, g_2) = a(k, g_1 \vee g_2)$$

          Additionally, for each $k \in K$:
          \begin{align*}
            (g_1 \vee g_2)(k) \vee_{k, (g_1 \vee g_2)} a(k, g) 
            &= (g_1(k) \vee_{k, (g_1 \vee g_2)} g_2(k)) \vee_{k, (g_1 \vee g_2)} a(k, g) \\
            &= g_1(k) \vee_{k, (g_1 \vee g_2)} (g_2(k) \vee_{k, (g_1 \vee g_2)} a(k, g)) \\
            &= g_1(k) \vee_{k, (g_1 \vee g_2)} g_2(k) \\
            &= (g_1 \vee g_2)(k)
          \end{align*}
        \end{proof}

        For an autofill mapping $g$, we can define the \emph{concrete dependencies} of a key $k \in K$, which are a set of non-autofill keys of $g$ that are sufficient to derive $k$'s dependencies:

        $$c(k, g) := \bigcup_{k' \in d(k, g(k))} \begin{cases}
          \{k'\} & \text{if } g(k') \neq a(k, g) \\
          c(k', g) & \text{otherwise}
        \end{cases}  $$


        Merging two mappings can be done recursively. Given mappings $g_1$ and $g_2$ and a key $k$, we compute the values $g_1(k), g_2(k)$ and their dependency sets $d(k, g_1(k)), d(k, g_2(k))$. We recursively merge $g_1$ and $g_2$ on each key in either dependency set, caching intermediate values to avoid repetated recursive calls. Finally, we compute the join and cache it in the database.

        We may consider merging a mapping with a singleton mapping, which specifies the value of a single key and otherwise contains only default values. In this case, merging will change this value and all its direct or indirect dependencies. Merging with a singleton is similar to a ``database insert'', updating the value of a given key.

\end{document}
