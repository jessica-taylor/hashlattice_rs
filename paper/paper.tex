
\documentclass{article}

\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\newtheorem{theorem}{Theorem}

\title{Semilattice Graphs for Distributed Databases}
\author{Jessica Taylor}
\date{\today}

\begin{document}
    \maketitle
    
    \section{Introduction}
        A \emph{semilattice} is a set $L$ with a binary operation $\vee$ (``join'') that is commutative ($x \vee y = y \vee x$), associative ($(x \vee y) \vee z = x \vee (y \vee z)$), and idempotent ($x \vee x = x$).

        In databases, lattices are useful for defining a notion of a most updated value. For example, with $L$ as a set of sets of messages and $\vee = \cup$, the lattice represents sets of messages that are updated to include more messages as they come in.


    \section{Semilattice Graphs}

        A common problem in networked computing is dependency managament. A software package may depend on a set of other packages, each of which depends on another set of packages. We consider extending semilattices to semilattice graphs to handle dependency management.
        
        A \emph{semilattice graph} consists of:

        \begin{itemize}
            \item A set of keys $K$.
            \item A set of values $V$.
            \item A dependency function $d : K \times V \rightarrow 2^K$ that maps each key to a finite set of keys, its dependencies.
            \item A join function $j : (\Sigma (k: K, x : V, y : V), d(k, x) \cup d(k, y) \rightarrow V) \rightarrow V$ that joins two values given their dependencies. (The sigma set $\Sigma (a: A), B(a)$ denotes a set of pairs $(a, b)$ where $a \in A$ and $b \in B(a)$.)
        \end{itemize}

        And satisfies the following properties:

        \begin{itemize}
            \item $d$ must be well-founded; that is, there are no infinite sequences $k_1, k_2, \ldots \in K$ and $v_1, v_2, \ldots \in V$ such that $k_{i+1} \in d(k_i, v_i)$ for $i = 1, \ldots$
            \item $j$ must be a valid join function; for any $k : K$, $g: K \rightarrow V$, defining $x \vee_{k,g} y := j(k, x, y, g|_{d(k, x) \cup d(k, y)})$, then $(V, \vee_{k,g})$ must be a semilattice.
            \item $j$ must not grow dependencies; that is, for any $k : K$, $g: K \rightarrow V$, $x, y \in V$, we must have $d(k, x \vee_{k, g} y) \subseteq d(k, x) \cup d(k, y)$.
        \end{itemize}

        It is now possible to define a semilattice over a semilattice graph. This lattice's items are functions $K \rightarrow V$ (called \emph{mappings}) and the join operation is defined as follows:

        $$ (g_1 \vee g_2)(k) := g_1(k) \vee_{k, (g_1 \vee g_2)} g_2(k) $$

        where the recursion is well-founded due to $d$ being well-founded.

    \section{Autofills}

        Mappings may be infinite in general, and even finite ones contain a large number of keys. It is therefore computationally infeasible to store a mapping as a set of $K \times V$ pairs. Accordingly, we define \emph{autofills} to fill in lattice values automatically from a set of other values.


        Define $d^*(k, g) := \{k\} \cup \bigcup_{k' \in d(k, g(k))} d^*(k', g)$, the transitive closure of $d$, where $g$ is a mapping. The recursion is well-founded (and $d^*(k, g)$ is finite) because $d$ is well-founded.

        Note that $d^*(k, g_1 \vee g_2) \subseteq d^*(k, g_1) \cup d^*(k, g_2)$.

        An \emph{autofill} for a semilattice graph is a function $a : \forall (k:K, g: V \rightarrow K), V$ that satisfies:

        \begin{itemize}
          \item
            $a(k, g_1) = a(k, g_2)$ if $g_1(k) = g_2(k)$ for each $k \in d^*(k, g_1)$; that is, $a(k, g)$ must only depend on the values of $g$ on $d^*(k, g)$.
          \item
            $a(k, g_1) \vee_{k, g_1 \vee g_2} a(k, g_2) = a(k, g_1 \vee g_2)$; that is, the join of two autofill values on two mappings must be an autofill value on the joined mapping.
        \end{itemize}

        A mapping $g : K \rightarrow V$ is an \emph{autofill mapping} if:
        
        \begin{itemize}
          \item $g(k) = a(k, g)$ for all but a finite number of $k$ values.
          \item $g(k) \vee_{k, g} a(k, g) = g(k)$ for all $k \in K$.
        \end{itemize}

        An autofill mapping can be represented as a finite set of $K \times V$ pairs; the remaining values are filled in automatically.

        \begin{theorem}
          Let $g_1, g_2 : K \rightarrow V$ be autofill mappings. Then $g_1 \vee g_2$ is an autofill mapping.
        \end{theorem}

        \begin{proof}

          Whenever $g_1(k) = a(k, g_1)$ and $g_2(k) = a(k, g_2)$ (which is true for all but a finite number of $k$ values):
           $$(g_1 \vee g_2)(k) = g_1(k) \vee_{k, (g_1 \vee g_2)} g_2(k) = a(k, g_1) \vee_{k, (g_1 \vee g_2)} a(k, g_2) = a(k, g_1 \vee g_2)$$

          Additionally, for each $k \in K$:
          \begin{align*}
            (g_1 \vee g_2)(k) \vee_{k, (g_1 \vee g_2)} a(k, g) 
            &= (g_1(k) \vee_{k, (g_1 \vee g_2)} g_2(k)) \vee_{k, (g_1 \vee g_2)} a(k, g) \\
            &= g_1(k) \vee_{k, (g_1 \vee g_2)} (g_2(k) \vee_{k, (g_1 \vee g_2)} a(k, g)) \\
            &= g_1(k) \vee_{k, (g_1 \vee g_2)} g_2(k) \\
            &= (g_1 \vee g_2)(k)
          \end{align*}
        \end{proof}


        Merging two mappings can be done recursively. Given mappings $g_1$ and $g_2$ and a key $k$, we compute the values $g_1(k), g_2(k)$ and their dependency sets $d(k, g_1(k)), d(k, g_2(k))$. We recursively merge $g_1$ and $g_2$ on each key in either dependency set, caching intermediate values to avoid repetated recursive calls. Finally, we compute the join and cache it in the database.

        We may consider merging a mapping with a singleton mapping, which specifies the value of a single key and otherwise contains only default values. In this case, merging will change this value and all its direct or indirect dependencies. Merging with a singleton is similar to a ``database insert'', updating the value of a given key.

\end{document}
